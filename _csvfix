#compdef csvfix
local -a ascii_table block check date_format date_iso diff echo edit erase escape eval exclude exec file_info
local -a file_merge file_split find flatten from_xml head inter join lower map merge mixed money number order
local -a pad pivot printf put read_dsv read_fixed read_multi remove rmnew rowsort sequence shuffle sort split_char
local -a split_fixed split_regex sql_delete sql_insert sql_update squash stat summary tail template timestamp to_xml
local -a trim truncate unflatten unique upper validate write_dsv write_fixed write_multi


# usage: csvfix command [flags] file ...
if (( CURRENT == 2 )); then
  local curcontext="$curcontext" expl state line args ret=1
    _arguments -n ':command:(( ascii_table\:"produce ascii table"\
      block\:"perform actions on blocks of CSV records"\
      check\:"check CSV record format conforms to CSV standard"\
      date_format\:"perform date formatting"\
      date_iso\:"convert dates to ISO format"\
      diff\:"compare two CSV files"\
      echo\:"echo input to output"\
      edit\:"edit fields"\
      erase\:"erase fields using regular expressions"\
      escape\:"escape special characters"\
      eval\:"expression evaluation"\
      exclude\:"exclude fields from output"\
      exec\:"execute external command"\
      file_info\:"add file information to output"\
      file_merge\:"merge multiple sorted CSV files"\
      file_split\:"split into files"\
      find\:"find rows matching regular expression or range"\
      flatten\:"flatten to single row"\
      from_xml\:"convert from XML to CSV"\
      head\:"list first CSV records"\
      inter\:"interleave fields from two CSV sources"\
      join\:"perform relational join"\
      lower\:"convert to lowercase"\
      map\:"map betwen CSV field values"\
      merge\:"merge fields"\
      mixed\:"convert to mixed case"\
      money\:"format fields as money/currency values"\
      number\:"convert formatted numeric fields to ordinary numeric"\
      order\:"change field order"\
      pad\:"pad CSV records to fixed number of fields"\
      pivot\:"simple pivot tables"\
      printf\:"printf-style formatting"\
      put\:"put literal or env variable into CSV output"\
      read_dsv\:"convert DSV (delimiter separated variables) data to CSV"\
      read_fixed\:"convert fixed format data to CSV"\
      read_multi\:"read multi-line data"\
      remove\:"remove rows matching regular expression or range"\
      rmnew\:"remove embedded newlines"\
      rowsort\:"in-row sort of CSV fields"\
      sequence\:"add sequence numbers"\
      shuffle\:"randomly shuffle rows or fields"\
      sort\:"sort CSV input on one or more fields"\
      split_char\:"split using regular expression"\
      split_fixed\:"split input using fixed sizes"\
      split_regex\:"split at character or character type transition"\
      sql_delete\:"generate SQL DELETE statements"\
      sql_insert\:"generate SQL INSERT statements"\
      sql_update\:"generate SQL UPDATE statements"\
      squash\:"squash duplicate rows to single row"\
      stat\:"produce record/field stats for CSV files"\
      summary\:"summarise CSV data"\
      tail\:"list last CSV records"\
      template\:"output via template"\
      timestamp\:"add timestamp to CSV data"\
      to_xml\:"convert CSV to XML"\
      trim\:"trim leading/trailing spaces"\
      truncate\:"truncate CSV records"\
      unflatten\:"convert single row to multiple rows"\
      unique\:"filter duplicate CSV records"\
      upper\:"convert to uppercase"\
      validate\:"validate CSV data files"\
      write_dsv\:"convert CSV to DSV format"\
      write_fixed\:"convert CSV to fixed format"\
      write_multi\:"convert CSV to multi-line records"\
      ))' && ret=1
else
# echo words[2]
case $words[2] in
  (ascii_table)
    _arguments '-h[comma-separated list of table headers]:headers:'\
     '-ra[list of field indexes to right-align]:fields:'\
     '-s[separator after every line of data]:insert:'\
     '-ibl[ignore blank input lines]'\
     '-ifn[ignore field name record]'\
     '-o[write output to file rather than standard output]:file:_files'\
     '-skip[t if test t is true, do not process or output record]'
  ;;

  (block)
    _arguments    '-be[expression marking start of block]:expr:'\
     '-ee[expression marking end of block]:expr:'\
     '-r[block from output]:remove:'\
     '-k[block in output]:keep:'\
     '-m[mark block and non-block records]:mark:'\
     '-x[begin/end records from block]:exclude:'\
     '-ibl[ignore blank input lines]'\
     '-sep[specify CSV field separator character]:s:'\
     '-rsep[as for -sep but retain separator on output]:s:'\
     '-osep[specifies output separator]:s:'\
     '-hdr[write the string s out as a header record]:s:'\
     '-ifn[ignore field name record]'\
     '-smq[use smart quotes on output]'\
     '-sqf[specify fields that must be quoted]:fields:'\
     '-o[write output to file rather than standard output]:file:_files'
  ;;

  (check)
    _arguments    '-nl[embedded newlines in quoted fields]:allow:'\
     '-q[quietly - no output but return error indicator]:run:'\
     '-s[use sep as the field separator (default is ',' )]:sep:'\
     '-v[OK message for inputs that pass validation]:print:'
  ;;

  (date_format)
    _arguments   '-f[specify fields using numeric field indexes]:fields:'\
    '-fmt[format to to ue for output]:fmt:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (date_iso)
    _arguments   '-f[specify fields using numeric field indexes]:fields:'\
    '-m[specifies order of date components in d/m/y form]:mask:'\
    '-cy[specifies base year for 2-digit year values]:year:'\
    '-mn[specifies month names - default is English months]:names:'\
    '-bxl[list only records containing invalid dates]'\
    '-bdx[sliently exclude records containing invalid dates]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (diff)
    _arguments   '-f[fields to check for differences (default all)]:fields:'\
    '-q[not report, only return same/different status]:do:'\
    '-ic[case when diffing]:ignore:'\
    '-is[leading and trailing spaces when diffing]:ignore:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (echo)
    _arguments   '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (edit)
    _arguments   '-f[fields to apply edits to (default is all fields)]:fields:'\
    '-e[specify edit command - currently only s(ubstitute) implemented]:cmd:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (erase)
    _arguments '-f[list of fields to check for exclusion (default is all)]:fields:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-k[all fields are erased, retain empty row (default is to delete it)]:if:'\
    '-n[erase fields which do not match this regular expression]:regex:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-osep[specifies output separator]:s:'\
    '-pass[t if test t is true, output CSV record as is]'\
    '-r[erase fields that match this regular expression]:regexp:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-sep[specify CSV field separator character]:s:'\
    '-skip[t if test t is true, do not process or output record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'
  ;;

  (escape)
    _arguments   '-f[fields to apply escaping to (default is all fields)]:fields:'\
    '-s[list of characters to be escaped]:chars:'\
    '-e[string to use for escaping (default is backslash)]:esc:'\
    '-sql[perform SQL single quote escaping]'\
    '-noc[turns off CSV interenal escaping]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'\
  ;;

  (eval)
    _arguments '-d[input and only write result of -e evaluations]:discard:'\
    '-e[expression to evaluate]:expr:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ibl[ignore blank input lines]'\
    '-if[allows conditional expression evaluation]:expr:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-osep[specifies output separator]:s:'\
    '-pass[t if test t is true, output CSV record as is]'
    '-r[replace field f with result of evaluating expr]:f,expr'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-sep[specify CSV field separator character]:s:'\
    '-skip[t if test t is true, do not process or output record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'
  ;;

  (exclude)
    _arguments '-f[list of fields to exclude]:fields:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ibl[ignore blank input lines]'\
    '-if[exclude fields specified by -f if expr evaluates to true]:expr:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-osep[specifies output separator]:s:'\
    '-pass[t if test t is true, output CSV record as is]'\
    '-rf[list of fields to exclude, starting from end of record]:fields:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-sep[specify CSV field separator character]:s:'\
    '-skip[t if test t is true, do not process or output record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'
  ;;

  (exec)
    _arguments   '-c[command line to execute]:cmd:'\
    '-r[CSV input with command output]:replace:'\
    '-ix[ignore exit codes from cmd with values less than or equal to ecode]:ecode:'\
    '-d[mode - print expanded command but dont execute it]:debug:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (file_info)
    _arguments   '-b[path from filename]:remove:'\
    '-tc[file name and line number as two separate CSV fields]:output:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (file_merge)
    _arguments   '-f[fields to compare when merging (default all)]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:string:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (file_split)
    _arguments   '-f[fields to use as basis for split]:fields:'\
    '-fd[directory to place output files in (default is current)]:dir:'\
    '-fp[prefix to use to generate filenames(default is file_)]:pre:'\
    '-fx[extension to use to generate filenames(default is csv)]:ext:'\
    '-ufn[use field content to generate filenames]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (find)
    _arguments   '-f[fields to search]:fields:'\
    '-e[regex to search for - multiple -e flags are allowed]:expr:'\
    '-s[as for -e, but dont treat expr as regex]:expr:'\
    '-fc[specify field count to find]:count:'\
    '-r[range to search for - multiple -r flags are allowed]:range:'\
    '-ei[as for -e flag, but search ignoring case]:expr:'\
    '-si[as for -e flag, but dont treat expr as regex]:expr:'\
    '-n[count of matched rows only]:output:'\
    '-l[search for fields of given length (may be a range)]:length:'\
    '-if[only output line if eval expression evaluates to true]:expr:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sep[specify CSV field separator character]:sep:'\
    '-o[write output to file, rather than standard output]:file:_files'
  ;;

  (flatten)
    _arguments   '-k[specify list of key fields (default is first field)]:key:'\
    '-r[key in output (default is retain)]:remove:'\
    '-f[specify list of data fields (default is all but first)]:data:'\
    '-me[specify master record expression]:expr:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[if test t is true, do not process or output record]:t:'
  ;;

  (from_xml)
    _arguments   '-re[path of XML tag on which to begin new CSV record]:path:'\
    '-ex[specify paths to exclude from output]:path:'\
    '-np[do not output parent tag data]'\
    '-nc[do not output child tag data]'\
    '-na[do not output attribute data]'\
    '-ip[tag path for record as first CSV field]:insert:'\
    '-ml[specify multi-line text separator (default is a space)]:sep:'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (head)
    _arguments   '-n[display first count records (default is 10)]:count:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (inter)
    _arguments   '-f[specify fields to interleave]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (join)
    _arguments   '-f[list of fields to perform join on]:jlist:'\
    '-oj[outer join]:perform:'\
    '-inv[invert sense of join to exclude matching rows]'\
    '-ic[character case in join columns]:ignore:'\
    '-k[join fields in output]:keep:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (lower)
    _arguments   '-f[list of fields to convert (default is all)]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sep[specify CSV field separator character]:sep:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (map)
    _arguments   '-f[fields to perform mapping on (default is all)]:fields:'\
    '-fv[comma-separated list of values to map from]:vals:'\
    '-tv[possibly empty list oof values to map to]:vals:'\
    '-ic[case when mapping (default is to respect case)]:ignore:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (merge)
    _arguments   '-f[specify fields to merge (default is to merge all fields)]:fields:'\
    '-s[character(s) to use as separator]:sep:'\
    '-p[position to insert merged field in output]:pos:'\
    '-k[original merged fields in output]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (mixed)
    _arguments   '-f[list of fields to convert (default is all)]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sep[specify CSV field separator character]:sep:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (money)
    _arguments   '-f[fields to apply format to - default is all fields]:fields:'\
    '-dp[use character chr as decimal point symbol - default is full-stop]:chr:'\
    '-ts[use character chr as thousands separator - default is comma]:chr:'\
    '-cs[use string sym as currency symbol - default is none]:sym:'\
    '-ms[use string minus as prefix for negative values - default is "-"]:minus:'\
    '-ps[use string plus as prefix for positive values - default is none]:plus:'\
    '-cn[the amount being formatted as if it were cents, not dollars]:treat:'\
    '-r[fields with new format - default is to append fields to output]:replace:'\
    '-w[specify width of output, which will be right-aligned]:width:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (number)
    _arguments   '-f[fields to convert - default is all]:fields:'\
    '-fmt[format of input fields - one of EU or EN (default)]:fmt:'\
    '-es[replace fields that cannot be read with this string]:str:'\
    '-ec[conversion failure is an error]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (order)
    _arguments   '-f[specify fields using numeric field indexes]:fields:'\
    '-nc[not create fields missing in input]:do:'\
    '-xf[specify all but excluded fields]:fields:'\
    '-rf[as for -f, but specify fields from end of record]:fields:'\
    '-fn[specify fields using list of field names]:names:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (pad)
    _arguments   '-n[number of fields to pad to]:count:'\
    '-p[values to use for paddding (default is empty string)]:vals:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (pivot)
    _arguments   '-c[field to use for column headers]:field:'\
    '-r[field to use for row header]:field:'\
    '-a[action to perform (one of sum, avg, count)]:act:'\
    '-f[field that represents the fact you want to perform action on]:field:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (printf)
    _arguments   '-fmt[specify fields and printf-style formatters]:fmt:'\
    '-f[field order to pass to formatter]:fields:'\
    '-q[CSV quoting to each printf conversion]:apply:'\
    '-csv[treat output as CSV field and append to input row]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (put)
    _arguments   '-p[position in output(default is at end)]:pos:'\
    '-v[value to put]:val:'\
    '-e[name of environment variable to put]:env:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (read_dsv)
    _arguments   '-f[specify list of fields to convert (default is all)]:fields:'\
    '-s[specify DSV separator character (default is pipe symbol)]:sep:'\
    '-csv[treat field contents as CSV (double quotes are special)]'\
    '-cm[multiple separators into single instance]:collapse:'\
    '-ibl[ignore blank input lines]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (read_fixed)
    _arguments   '-f[specify fields to extract from fixed-format]:fields:'\
    '-k[trailing spaces on output]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (read_multi)
    _arguments   '-n[specify number of lines in each multi-line record]:lines:'\
    '-s[specify separator between records]:sep:'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (remove)
    _arguments   '-f[fields to search]:fields:'\
    '-e[regex to search for - multiple -e flags are allowed]:expr:'\
    '-s[as for -e, but dont treat expr as regex]:expr:'\
    '-fc[specify field count to remove]:count:'\
    '-r[range to search for - multiple -r flags are allowed]:range:'\
    '-ei[as for -e flag, but search ignoring case]:expr:'\
    '-si[as for -e flag, but dont treat expr as regex]:expr:'\
    '-n[count of non-matching rows only]:output:'\
    '-l[search for fields of given length (may be a range)]:length:'\
    '-if[dont output line if eval expression evaluates to true]:expr:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sep[specify CSV field separator character]:sep:'\
    '-o[write output to file, rather than standard output]:file:_files'
  ;;

  (rmnew)
    _arguments   '-s[separator text to replace newline]:sep:'\
    '-x[data after first newline in field]:exclude:'\
    '-f[fields to apply command to (default is all)]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (rowsort)
    _arguments   '-f[fields to sort (default is all)]:fields:'\
    '-a[ascending (default)]:sort:'\
    '-d[descending]:sort:'\
    '-l[order (default)]:lexographic:'\
    '-n[order]:numeric:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (sequence)
    _arguments   '-n[specify sequence start value]:start:'\
    '-i[increment between sequence numbers]:inc:'\
    '-d[decrement between sequence numbers (mutually exclusive with -i)]:dec:'\
    '-p[provide width (with left zero padding) of sequence numbers]:pad:'\
    '-f[specify index of field to place sequence numberr at]:pos:'\
    '-m[specify mask to apply to sequence number]:mask:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (shuffle)
    _arguments   '-n[only output the first 'count' rows after shuffle]:count:'\
    '-rs[specify seed to use for random number generator]:seed:'\
    '-f[shuffle specified fields instead of rows]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (sort)
    _arguments   '-f[specify fields on which to sort]:fields:'\
    '-rh[header in output]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (split_char)
    _arguments   '-f[index of the field to be split (required)]:field:'\
    '-c[character to split at (default is space)]:char:'\
    '-tcn[at first transition from character to number]:split:'\
    '-tnc[at first transition from number to character]:split:'\
    '-k[field being split in output (default is discard it)]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (split_fixed)
    _arguments   '-f[index of the field to be split]:field:'\
    '-p[list of positions to split, in start:len format]:plist:'\
    '-l[lengths of fields to split (mutually exclusive with -p)]:lengths:'\
    '-k[field being split in output (default is discard it)]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (split_regex)
    _arguments   '-f[index of the field to be split]:field:'\
    '-r[regular expression to use to perform split]:regex:'\
    '-ic[case when matching regular expressions]:ignore:'\
    '-k[field being split in output (default is discard it)]:retain:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (sql_delete)
    _arguments   '-w[fields to use to generate the SQL WHERE clause]:fields:'\
    '-t[name of table to update]:table:'\
    '-s[specifies statement separator (default ';')]:sep:'\
    '-nq[specifies fields not to quote on output]:fields:'\
    '-qn[quoting of NULL values]:force:'\
    '-en[empty CSV fields to NULLs]:covert:'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (sql_insert)
    _arguments   '-f[fields to use to generate the SQL statement]:fields:'\
    '-t[name of table to insert into]:table:'\
    '-s[specifies statement separator (default ';')]:sep:'\
    '-nq[specifies fields not to quote on output]:fields:'\
    '-qn[quoting of NULL values]:force:'\
    '-en[empty CSV fields to NULLs]:covert:'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (sql_update)
    _arguments   '-f[fields to use to generate the SQL SET clause]:fields:'\
    '-w[fields to use to generate the SQL WHERE clause]:fields:'\
    '-t[name of table to update]:table:'\
    '-s[specifies statement separator (default ';')]:sep:'\
    '-nq[specifies fields not to quote on output]:fields:'\
    '-qn[quoting of NULL values]:force:'\
    '-en[empty CSV fields to NULLs]:covert:'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (squash)
    _arguments   '-f[fields specifying key (required)]:fields:'\
    '-n[output only duplicate rows (required)]:fields:'\
    '-nn[value to use if -n field contains non-numeric value]:val:'\
    '-rn[treat -n fields as real numbers rather than as integers]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (stat)
    _arguments   '-fs[full record stats (default is simplified output)]:produce:'\
    '-fn[that input contains a header record listing field names]:specify:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (summary)
    _arguments   '-avg[calculate numeric average of specified fields]:fields:'\
    '-frq[prepend frequencies of specified fields to output]:fields:'\
    '-max[find and display maximum of fields]:fields:'\
    '-min[find and display minimum of fields]:fields:'\
    '-med[calculate median of fields]:fields:'\
    '-mod[calculate mode of fields]:fields:'\
    '-sum[perform summation of fields]:fields:'\
    '-siz[find max and min lengths of all fields]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (tail)
    _arguments   '-n[display last count records (default is 10)]:count:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (template)
    _arguments   '-ft[specify name of template file]:file:_files'\
    '-fn[specify template for generating file names]:ftpl:'\
    '-ts[specifies a string containing the template]:str:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (timestamp)
    _arguments   '-d[only date part of timestamp]:display:'\
    '-t[only time part of timestamp]:display:'\
    '-n[timestamp as numeric value with no separators]:display:'\
    '-rt[update stamp in real time as records are written]'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (to_xml)
    _arguments   '-xf[XML specification file - produce XHTML table if omitted]:file:_files'\
    '-in[indentation to use - 'tabs' means indent using tabs]:ind:'\
    '-et[always outoput explicit end-tags]'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (trim)
    _arguments   '-f[fields to trim (default is all)]:fields:'\
    '-l[leading whitespace]:trim:'\
    '-t[trailing whitespace]:trim:'\
    '-a[all whitespace]:remove:'\
    '-s[all multiple whitespace to single space]:trim:'\
    '-w[specifies widths to truncate fields to]:widths:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (truncate)
    _arguments   '-n[number of fields to truncate to]:count:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'\
    '-pass[t if test t is true, output CSV record as is]'
  ;;

  (unflatten)
    _arguments   '-k[specify list of key fields (default is first field)]:key:'\
    '-n[numberr of data fields perr output row (default is 1)]:data:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (unique)
    _arguments   '-f[fields to test for uniqueness]:fields:'\
    '-d[only duplicate rows]:output:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sqf[specify fields that must be quoted]:fields:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (upper)
    _arguments   '-f[list of fields to convert (default is all)]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-ifn[ignore field name record]'\
    '-smq[use smart quotes on output]'\
    '-sep[specify CSV field separator character]:sep:'\
    '-o[write output to file rather than standard output]:file:_files'
  ;;

  (validate)
    _arguments   '-vf[specify file containing validation rules]:file:_files'\
    '-om[output mode (pass,fail,report)]:mode:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (write_dsv)
    _arguments   '-f[specify list of fields to convert (default is all)]:fields:'\
    '-s[specify DSV separator character (default is pipe symbol)]:sep:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (write_fixed)
    _arguments   '-f[specify fields and widths to to output as fixed-format]:fields:'\
    '-ibl[ignore blank input lines]'\
    '-sep[specify CSV field separator character]:s:'\
    '-rsep[as for -sep but retain separator on output]:s:'\
    '-osep[specifies output separator]:s:'\
    '-hdr[write the string s out as a header record]:s:'\
    '-ifn[ignore field name record]'\
    '-o[write output to file rather than standard output]:file:_files'\
    '-skip[t if test t is true, do not process or output record]'
  ;;

  (write_multi)
    _arguments    '-m[fields comprising the master record (required)]:fields:'\
     '-d[fields comprising the detail records (default is all not in master)]:fields:'\
     '-rs[specify record separator (default is none)]:sep:'\
     '-ibl[ignore blank input lines]'\
     '-sep[specify CSV field separator character]:s:'\
     '-rsep[as for -sep but retain separator on output]:s:'\
     '-osep[specifies output separator]:s:'\
     '-hdr[write the string s out as a header record]:s:'\
     '-ifn[ignore field name record]'\
     '-smq[use smart quotes on output]'\
     '-sqf[specify fields that must be quoted]:fields:'\
     '-o[write output to file rather than standard output]:file:_files'
  ;;
esac

# (P)interpret content of variable as variable name
    # echo ${(P)words[2]}
    # _arguments ${(P)words[1]}
    # comm=${(P)words[1]}
    # echo $comm
    # _message
fi

#  vim: set ts=2 sw=2 tw=0 expandtab foldenable foldmethod=manual foldclose= :
